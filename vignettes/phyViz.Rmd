---
title: "Getting started with the package **phyViz**"
author: "Lindsay Rutter, Susan Vanderplas, Di Cook"
output: 
  knitrBootstrap::simple_document:
    toc: TRUE
    main: TRUE
    theme: cerulean
    highlight: idea
    clean_supporting: TRUE
---


<!--
%\VignetteEngine{knitr::knitr}
%\VignetteDepends{knitr}
%\VignetteIndexEntry{phyViz: Phylogenetic Visualization}

-->

**Description:** The **phyViz** package provides tools to examine genealogical data, generating basic statistics on their graphical structures using parent and child connections, and displaying the results. The genealogy can be drawn in relation to additional variables, such as development year, and the shortest path distances between genetic lines can be determined and displayed. Production of pairwise distance matrices and phylogenetic diagrams constrained by generation count are also available in the visualization toolkit. This vignette is intended to walk readers through the different methods available with the package.

**Caution:** igraph must be used with version >= 0.7.1

# Preprocessing Pipeline

There is a preprocessing pipeline to follow before visualizing your genealogical data. First, you must load the necessary libraries. Note that loading the phyViz library should automatically load several dependent libraries (ggplot2, igraph, plyr, reshape2, stringr): 

```{r, echo=4:6 , warning=F, message=F}
options(warn=-1, width=80)

library(knitr)
opts_chunk$set(tidy=T, results="hold", comment="#|")

library(phyViz)
library(roxygen2)
```

In the **phyViz** package, there is an example dataset containing genealogical information on soybean varieties called **sbTree.rda**. It may be helpful to load that example file so that you can follow along with the commands and options introduced in this vignette. To ensure that you have uploaded the correct, raw **sbTree.rda** file, you can observe the first six lines of it, and also determine its class type:

```{r}
data(sbTree)
head(sbTree)
class(sbTree)
```

We see that the **sbTree* data file is a data frame structure with five variables per row. Each row contains a child node character label and parent node character label. Each row also contains a numeric value corresponding to the year the child node was introduced, an integer value of the protein yield of the child node, and a logical value whether or not the year of introduction of the child node was imputed.

Now that the sbTree file has been loaded as a data frame, it must now be converted into a graph object using the **treeToIG()** function. The **treeToIG()** function requires a data frame as input, and that data frame should be structured such that each row represents an edge with a child and parent relationship. For more information, try using the help command on the function:

```{r}
help(treeToIG)
```

This allows you to view a more thorough description of the function arguments. For instance, we see that the function takes optional parameter arguments, such as *vertexinfo* (a list of columns of the data frame which provide information for the starting "child" vertex, or a separate data frame containing information for each vertex with the first column as the vertex name), *edgeweights* (a column that contains edge values, with a default value of unity), and *isDirected* (a boolean value that describes whether the graph is directed (true) or undirected (false); the default is false).

In this example, we want to produce an undirected graph object that contains all edge weight values of 1, because our goal is to set an edge value of unity for every pair of vertices (individuals) that are related as parent and child. The **treeToIG()** function uses the software **igraph** to convert the data frame into a graph object. For clarity, we will assign the outputted graph object the name **ig** (for igraph object), and then examine its class type:

```{r}
ig <- treeToIG(sbTree)
class(ig)
```

If successful, we can confirm that the **ig** object is of class type **igraph**.

We can add the other data we have about each of the nodes in **ig** in several ways. As we saw earlier, each row of the sbTree dataset contains information about each child. To append that data to the **ig** object, we can use the same command as before, but specify the **vertexinfo** parameter as follows: 

```{r}
ig <- treeToIG(sbTree, vertexinfo=c("year", "yield", "year.imputed"))
```

If we have separate data sets with node information, we can use that instead. For the example dataset, we must first obtain the node information: 

```{r}
library(plyr)
nodes <- unique(sbTree[,1:4])

# get a data frame of all parents whose parents are not known (i.e. parents who are not listed as children as well)
extra.nodes <- unique(data.frame(child=sbTree$parent[!sbTree$parent%in%sbTree$child & !is.na(sbTree$parent)], stringsAsFactors=FALSE))

# We may not have information for these extra nodes, but they still need to be included in the dataset
nodes <- rbind.fill(nodes, extra.nodes)
rm(extra.nodes)

# We can now specify our vertex information using the data frame nodes: 
ig <- treeToIG(sbTree, vertexinfo=nodes)
```

The ig object is used in many of the other functions included with this package. 


# Functions for Individual Vertices

The **phyViz** package offers several functions that you can use to obtain information for individual vertices.

First, the function **isParent()** can return a logical variable to indicate whether or not the second variety is a parent of the first variety.

```{r}
isParent("Young","Essex",sbTree)
isParent("Essex","Young",sbTree)
```

We see that "Essex" is a parent of "Young".

Similarly, the function **isChild()** can return a logical variable to indicate whether or not the first variety is a child of the second variety.

```{r}
isChild("Young","Essex",sbTree)
isChild("Essex","Young",sbTree)
```

We see that, as expected, "Young" is a child of "Essex".

It is also possible to derive the year of a given variety using the **getYear()** function:

```{r}
getYear("Young",sbTree)
getYear("Essex",sbTree)
```

Fortunately, the returned year values are consistent, as the "Young" variety (1968) is a child to the "Essex" variety (1962) by an age difference of six years.

In some cases, you may wish to obtain a complete list of all the parents of a given variety. This can be achieved using the **getParent()** function:

```{r}
getParent("Young",sbTree)
getParent("Tokyo",sbTree)
getYear("Tokyo", sbTree)
```

We learn from this that "Essex" is not the only parent of "Young"; it also has a parent "Davis". We also see that "Tokyo" does not have any documented parents in this dataset, and has an older year of introduction (1907) than other varieties we have examined thusfar.

Likewise, in other cases, you may wish to obtain a complete list of all the children of a given variety. This can be achieved using the **getChild()** function:

```{r}
getChild("Tokyo",sbTree)
getChild("Ogden",sbTree)
```

We find that even though the "Tokyo" variety is a grandparent of the dataset, it only has two children, "Ogden" and "Volstate". However, one of its children, "Ogden", produced twelve children.

If we want to obtain a list that contains more than just one generation past or previous to a given variety, then we can use the **getAncestors()** and **getDescendants()** functions, where we specify the number of generations we wish to view. This will return a data frame to us with the labels of each ancestor or descendant, along with the number of generations each one is from the given variety.

If we only look at one generation of ancestors of the "Young" variety, we should see the same information we did earlier when we used the **getParent()** function of the Young variety:

```{r}
getAncestors("Young",sbTree,1)
```

Indeed, we consistently see that the "Young" variety has only two ancestors within one generation, "Davis" and "Essex".

However, if we view the first five generations of ancestors of the "Young"" variety, we can view four more generations of ancestors past simply the parents:

```{r}
getAncestors("Young",sbTree,5)
dim(getAncestors("Young",sbTree,5))
```

In the second line of code above, we determined the dimensions of the returned data frame, and see that there are 27 ancestors within the first five ancestral generations of the "Young" variety.

Similarly, if we only look at the first generation of descendants of the "Ogden"" variety, we should see the same information as we did earlier when we used the **getChild()** function on the "Ogden" variety:

```{r}
getDescendants("Ogden",sbTree,1)
```

Indeed, we see again that "Ogden" has 12 children. 

However, if we want to view not only the children, but also the grandchildren, of the "Ogden" variety, then we can use this function, only now specifying two generations of descendants:

```{r}
getDescendants("Ogden",sbTree,2)
```

We see that variety "Ogden" has 16 grandchildren from its 12 children.

# Functions for Pairs of Vertices

Say you have a pair of vertices, and you wish to determine the degree of the shortest path between them, where edges represent parent-child relationships. You can accomplish that with the **getDegree()** function.

```{r}
getDegree("Tokyo", "Ogden", ig, sbTree)
getDegree("Tokyo", "Holladay", ig, sbTree)
```

As expected, the shortest path between the "Tokyo" and "Ogden" varieties has a value of one, as we already determined that they have a direct parent-child relationship. However, the shortest path between "Tokyo" and one of its descendants, "Holladay", has a much higher degree of seven.

Note that degree calculations in this case are not limited to one linear string of parent-child relationships; cousins and siblings and products thereof will also have computable degrees via nonlinear strings of parent-child relationships.

# Functions for the Whole Tree

There are many parameters about the tree that you may wish to know that cannot easily be obtained through images and tables. The function **getBasicStatistics()** will return graph theoretical measurements of the whole tree. For instance, is the whole tree connected? If not, how many separated components does it contain? In addition to these parameters, the **getBasicStatistics()** function will also return the number of nodes, the number of edges, the average path length, the graph diameter, among others:

```{r}
getBasicStatistics(ig)
```

In this case, we learn that our tree is actually not all connected by parent-child edges, and that instead, it is composed of 11 separate components. We see that the average path length of the tree is 5.333, that the graph diameter is 13, and that the logN value is 5.438. We also see that the number of nodes in the tree is 230, and the number of edges in the tree is 340.

But can we view a list of these nodes and edges? To do so, we can call the **getNodes()** and **getEdges()** commands to obtain lists of all the unique nodes and edges in the tree. Here, we obtain a list of the 340 edges (with each row containing the names of the two connected vertices, and an edge weight, if existent). We will simply view the first six rows of the object, and determine the number of edges by counting the number of rows (340):

```{r}
eList = getEdges(ig)
head(eList)
dim(eList)
```

We then obtain a list of the 230 nodes. Again, we only view the first six rows of the object, and determine the number of nodes by counting the number of rows (230).

```{r}
nList = getNodes(sbTree)
head(nList)
length(nList)
```

# Visualizing the Tree

Until this point, the vignette has introduced functions that return lists, data frames, and statistics about the genealogical dataset. However, the **phyViz** package also contains visualization tools for genealogical datasets. Access to various types of visual plots and diagrams of the lineage can allow genealogical researchers to more efficiently and accurately explore an otherwise complicated data structure. Below, we introduce functions in **phyViz** that produce visual outputs of the dataset.

## Plotting the Ancestors and Descendants of a Vertex

One visualization tool, **plotAncDes()**, allows the user to view the ancestors and descendants of a given variety. The inputted variety is highlighted in the center of the plot, ancestors are displayed to the left of the center, and descendants are displayed to the right of the center. The further left or right from the center, the larger the number of generations that particular ancestor/descendant is from the inputted and centered variety.

As such, this plotting command does not provide visual information about specific years associated with each related variety (as is done in some of the visualization tools introduced later), but it does group all varieties from each generation group onto the same position of the horizontal axis. Here, we specify that we want to plot 5 ancestor generations and 3 descendant generations of the variety "Essex":

```{r}
plotAncDes("Essex", sbTree, 5, 3)
```

We immediately see that this visual representation of the ancestors and descendants of a given variety can often provide enhanced readability compared to the list output provided in the previous similar functions, **getAncestors()** and **getDescendants()**.

We also see now that some node labels are repeated. For instance, the "5601T" variety appears twice, once as a grandchild (second generation descendant) of "Essex", and once as a great-granchild (third generation descendant) of "Essex". This is because there are two separate parent-child pathways between "Essex" and "5601T", one pathway with only one node ("Hutchson") between them, and one pathway with two nodes ("T80-69" and "TN89-39") between them.

However, in this visual tool, we are constraining the horizontal axis to generation count. Without allowing nodes to repeat, this data information cannot be clearly and succinctly presented. Most graph visualization software that genealogists might use to view their datasets do not allow for repeated nodes, as per the definition of a graph. Hence, the **plotAncDes()** function is one of the more unique visual tools of the **phyViz** package.

It should be noted that the **plotAncDes()** function, by default, highlights the centered variety label in pink. However, the user can alter this color, as we will show below. Furthermore, the user can specify additional grammar of graphics plotting tools (from the **ggplot2** package) to tailor the output of the **plotAncDes()** function.

For example, we will now change the color of the center variety label **vColor** to be highlighted in blue. Also, we will add a horizontal axis label called "Generation index", using the **ggplot2** syntax. Note that this time we do not specify the generational count for ancestors and descendants, and so the default value of three generations is applied for both cases. Remember, to determine such default values, as well as all possible function parameters, simply run the help command on the function of interest, as in help(plotAncDes).

```{r}
plotAncDes("Tokyo", sbTree, vColor = "blue") + ggplot2::labs(x="Generation index",y="")
```

We verify immediately that the "Tokyo" variety does not have any ancestors in this dataset, an observation consistent with what we discovered earlier. We also see the "Tokyo" variety only has two children, but has many more grandchildren, and great-grand children.

## Plotting the Path between Two Vertices

As this data set deals with soy bean lineages, it may be useful for agronomists to track how two varieties are related to each other via parent-child relationships. Then, any dramatic changes in protein yield, SNP varieties, and other measures of interest can be tracked across the genetic timeline, and pinpointed to certain varieties along the way.

The **phyViz** software can allow you to select two varieties of interest, and view the shortest pathway between them. You can produce a neat visual that informs you of all the varieties involved in the path between the two varieties of interest, as well as the years of all varieties involved in the path.

To produce and view this plot, two functions must be called in the order presented below (**getPath** and **plotPath**). We next introduce each of these two functions.

The **getPath** function determines the shortest path between the two inputted vertices, and takes into account whether or not the graph is directed. If there is a path, the list of vertices of the path (and their associated years) will be returned. For a directed graph, the direction matters. However, **getPath** will check both directions and return the path if it exists. The third parameter indicates the logical boolean of whether or not the graph is directed. Below, we look at all three possibilities (undirected and directed in reverse orders) between two varieties:

```{r}
getPath("Brim","Bedford", ig, sbTree, isDirected=FALSE)
```

To compute paths where direction matters, we must have a directed graph
```{r}
dirgraph = treeToIG(sbTree, vertexinfo=nodes, isDirected = TRUE)
getPath("Brim", "Bedford", dirgraph, sbTree, isDirected=TRUE)
```

```{r}
getPath("Bedford", "Brim", dirgraph, sbTree, isDirected=TRUE)
```

We can derive from the empty list returned in the last two of the three commands that the varieties "Brim" and "Bedford" are not connected by a linear sequence of parent-child relationships. Rather, they are derived from a branch as some point, as siblings and/or cousins. Unless you are working with a dataset that must be analyzed as a directed graph, it is best to use the **getPath** function with the undirected specification (F) as the third parameter.

As such, we save the path between these two varieties to a variable called **path**:

```{r}
path = getPath("Brim","Bedford", ig, sbTree, isDirected=F)
```

Now that we have a **path** object that consists of two lists (the variety names and years), we can plot the relationship between the two using plotPath(path)

```{r}
plotPathDF = plotPath(path)
```

Indeed, as predicted above, the image verifies that the two varieties "Brim" and "Bedford" are cousin-like relationships, and are not connected by a linear string of parent-child relationships. Also, as mentioned above, in this plot, the x-axis represents the years, meaning that the center of the text box for each variety represents its corresponding year.

If, for some reason, you are looking at *directed* phylogenetic trees, you will need to use the true logical condition for the third parameter of the function **getPath**. The example below will hopefully reassure you that if you use this condition on a pathway composed of linear parent-child relationships, then either ordering of the first two parameters will work:

```{r}
dirgraph = treeToIG(sbTree, vertexinfo=nodes, isDirected = TRUE)

path = getPath("Narow", "Tokyo", dirgraph, sbTree, isDirected=TRUE)
plotPathImage <- plotPath(path)
plotPathImage
```

## Plotting the Pathway between Two Vertices Superimposed on Tree

If you are curious to see the above-demonstrated shortest pathway between two vertices of interest, only now superimposed over all the varieties and edges in the whole tree, **phyViz** has a function (**plotPathOnTree**) that can achieve just that. 

<!--
The internal process is as follows: 
First, the **buildSpreadTotalDF** function creates a dataframe where the varieties are shuffled such that their overlap is minimized, even though the x-axis position will represent years. (Note: **binVector** will be explained in more detail at the end of this section).

```
binVector <- c(1,4,7,10,2,5,8,11,3,6,9,12)
spreadTotalDF <- buildSpreadTotalDF(ig, binVector)
head(spreadTotalDF)
```

Next, the **buildMinusPathDF** function takes the **ig** object and the **path** object (from the **getPath** function) as inputs. From these objects, it creates a data frame object of the label, x, and y values of all nodes in the tree. However, the data frame object does not include the labels of the path varieties, as they will be treated differently.

```
plotMinusPathDF <- buildMinusPathDF(path, ig)
head(plotMinusPathDF)
```

Third, the **buildEdgeTotalDF** function takes the **ig** object and creates a data frame object of the edges between all parent-child relationships in the graph.

```
edgeTotalDF <- buildEdgeTotalDF(ig)
head(edgeTotalDF)
```

Fourth, the **buildPlotTotalDF** function takes the **ig** object and the **path** object to create a data frame object of the text label positions for the varieties in the path, as well as the edges only in the varieties in the path.

```
plotTotalDF <- buildPlotTotalDF(path, ig)
head(plotTotalDF)
```

Now that we have generated the data frames needed to construct this type of visual object, we use them as input parameters to the **plotPathOnTree** function. 

-->
The outputted image will correctly position the node labels with x-axis representing the node year, and y-axis representing the node path index. Light grey edges between two nodes represent parent-child relationships between those nodes. To enhance the visual understanding of how the path-of-interest fits into the entire graph structure, the nodes within the path are labelled in boldface, and connected with light-green boldfaced edges.

```{r}
plotTotalImage <- plotPathOnTree(path=path, tree=sbTree, ig=ig)
plotTotalImage
```

Even though the edges of the large tree in this image are criss-crossing in all directions, that was not the focus, and hence the edges not belonging to the green path-of-interest are softly colored in a light gray. The highlight of this image was to keep all varieties in line with their appropriate year (corresponding to the x-axis), and to mitigate any overlap of the text of the varieties. Achieving this can be difficult, especially if your dataset has many varieties scrunched into a narrow set of years. That was the case with this dataset. As can be seen in the image above, most of the hundreds of varieties are associated with years between 1960 and 1975.

And this is where the explanation of the variable **binVector** (used as input parameters to the function **spreadTotalDF**) comes into play. As there is no uniform solution for this complicated problem, the **phyViz** package offers you the flexbility to changes these variables until you can optimize this image so that the text of the nodes of your tree overlap as little as possible. This can be done with a trial-and-error process by tweaking **binVector**'s order and length at the start.

Specifically, the length of **binVector** indicates how many bins of equal sizes should be allocated (where bins separate the vertices into groups of years). Theo order of **binVector** can be altered to avoid spatial collisions in labels.

The **binVector** will determine the order that increasing y index positions are repeatedly assigned to. For instance, if binVector = c(1,4,7,10,2,5,8,11,3,6,9,12), then y-axis position one will be assigned to a variety in the first bin of years, y-axis position two will be assigned to a variety in the fourth bin of years, ...., and y-axis position thirteen will be assigned again to a variety in the first bin of years. This will be repreated until all varieties from all bins have been assigned in that order. This vector can help minimize overlap of the labelling of varieties, as varieites from the same bins (near each other on the x-axis for years) will not have consecutive y-axis values.

The two examples below will show the importance of selecting an appropriate number of bins and order of bins to minimize overlap: 

```{r}
plotTotalImage <- plotPathOnTree(path=path, tree=sbTree, ig=ig, binVector=1:12)
plotTotalImage
```

In this case, even though the number of bins is as large as the clearer-labelled image above, the order of the bins is such that varieties of consecutive x-values (years) will also have consecutive y-values (indices), and hence will be likely to overlap for years with many varieties.

```{r}
plotTotalImage <- plotPathOnTree(path=path, tree=sbTree, ig=ig, binVector=1:2)
plotTotalImage
```

In this example, we see that with such a small number of bins chosen, the y-axis position designation will be similar to its original random state, and there is again much overlap in text variety labels in the year ranges where varieties occur the most.

## Generating a Pairwise Distance Matrix between Set of Vertices

It may also be of interest to scientists studying phylogenetics to generate heat maps where the color of each index of the map indicates the distance or years between two vertices.

The package **phyViz** also provides functions for that purpose. Specifically, for a given set of vertices, a heat map of the distance (degree of the shortest path) between all pairs of vertices can be constructed with the **plotDegMatrix** function:


```{r}
varieties <- c("Beeson", "Brim", "Dillon", "Narow", "Zane", "Hood", "York", "Calland", "Columbus", "Crawford", "Kershaw", "Kent","Bragg", "Davis","Tokyo","Hagood","Young","Essex","Holladay","Cook","Century","Pella","Forrest","Gasoy","Cutler")
heatMapDegreeImage <- plotDegMatrix(varieties,ig,sbTree)
heatMapDegreeImage
```

In a similar function, **plotYearMatrix**, the difference in years between all pairwise combinations of vertices can be constructed and viewed:

```{r}
varieties <- c("Beeson", "Brim", "Dillon", "Narow", "Zane", "Hood", "York", "Calland", "Columbus", "Crawford", "Kershaw", "Kent","Bragg", "Davis","Tokyo","Hagood","Young","Essex","Holladay","Cook","Century","Pella","Forrest","Gasoy","Cutler")
heatMapYearImage <- plotYearMatrix(varieties,sbTree)
heatMapYearImage
```

Running this function on this particular set of vertices shows that most combinations of varieties are only a few decades apart in years, with only very few sets of vertices showing difference in years on the order of five or six decades.


# Conclusion

The various options of the **phyViz** package can offer you different ways of visually interpreting your trees that each come with advantages and disadvantages. While some visualizations connect nodes to their years, other visualizations lax this idea, and instead connect nodes based on their generation surrounding a given node. And still other visualizations from **phyViz** will allow you to either focus on one pathway, or view that pathway superimposed across the entire tree for reference. Hopefully, the package will have something to offer to you in your data analysis.
