<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

  <head>

    <meta charset="utf-8" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="generator" content="pandoc" />

        <meta name="author" content="Lindsay Rutter, Susan Vanderplas, Di Cook" />
    
    
    <title>How to use the package phyViz</title>

        <script src="phyViz_files/jquery-1.11.0/jquery.min.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link href="phyViz_files/bootstrap3-3.2.0/css/bootstrap.min.css" rel="stylesheet" />
    <link href="phyViz_files/bootstrap3-3.2.0/css/themes/default/bootstrap.min.css" rel="stylesheet" />
    <script src="phyViz_files/bootstrap3-3.2.0/js/bootstrap.min.js"></script>
    <link href="phyViz_files/highlightjs-8.2/highlight/default.css" rel="stylesheet" />
    <script src="phyViz_files/highlightjs-8.2/highlight.pack.js"></script>
    <link href="phyViz_files/MagnificPopup-0.9.9/magnific-popup.css" rel="stylesheet" />
    <script src="phyViz_files/MagnificPopup-0.9.9/magnific-popup.js"></script>
    <link href="phyViz_files/knitrBootstrap-0.0.1/css/knitrBootstrap.css" rel="stylesheet" />
    <script src="phyViz_files/knitrBootstrap-0.0.1/js/knitrBootstrap.js"></script>
    
    
  </head>

  <body data-spy="scroll" data-target="#toc">
    <div id="wrapper" class="container">
      <div class="row">
        <div class="contents col-xs-12 col-md-12">

          
                    <div id="header">
            <h1 class="title">How to use the package <strong>phyViz</strong></h1>
                                                <h4 class="author"><em>Lindsay Rutter, Susan Vanderplas, Di Cook</em></h4>
                                              </div>
                    
<!--
%\VignetteEngine{knitr::knitr}
%\VignetteDepends{knitr}
%\VignetteIndexEntry{phyViz: Phylogenetic Visualization}

-->
<p><strong>Description:</strong> The <strong>phyViz</strong> package allows phylogeneticists to visualize and interpret their trees in multiple ways, each which come with their pros and cons. This vignette is intended to walk readers through the different options available with the package.</p><p><strong>Caution:</strong> igraph must be used with version &gt;= 0.7.0</p><div id="preprocessing-pipeline" class="section level1"><h1>Preprocessing Pipeline</h1><p>There is a preprocessing pipeline that you must use before visualizing your phylogentic tree. First, you must load the necessary libraries. Note that loading the phyViz library should automatically load three required libraries (plyr, reshape2, igraph):</p><div class="row"><button class="source R toggle btn btn-xs btn-primary"><span class="glyphicon glyphicon-chevron-down"></span> R source</button>
<pre style=""><code class="source r">library(phyViz)
library(igraph)
library(ggplot2)</code></pre></div><p>In the <strong>phyViz</strong> package, there is an example file containing phylogenetic tree of soybean varieties called <strong>sbTree.rda</strong>. It may be helpful to load that example file so that you can follow along with the commands and options introduced in this vignette. To ensure that you have uploaded the correct, raw <strong>sbTree.rda</strong> file, you can observe the first six lines of it:</p><div class="row"><button class="source R toggle btn btn-xs btn-primary"><span class="glyphicon glyphicon-chevron-down"></span> R source</button>
<pre style=""><code class="source r">data(sbTree)
head(sbTree)</code></pre>
<button class="output R toggle btn btn-xs btn-success"><span class="glyphicon glyphicon-chevron-down"></span> R output</button>
<pre style=""><code class="output r">#|           child year yield year.imputed min.repro.year parent.type    parent
#| 1         5601T 1981    NA         TRUE            Inf      mother Hutcheson
#| 2         Adams 1948  2734        FALSE           1960      mother  Dunfield
#| 3          A.K. 1910    NA         TRUE           1912      mother      <NA>
#| 4 A.K. (Harrow) 1912  2665        FALSE           1955      mother      A.K.
#| 5        Altona 1968    NA        FALSE            Inf      mother  Flambeau
#| 6         Amcor 1979  2981        FALSE            Inf      mother  Amsoy 71
</code></pre></div><p>Now that the sbTree file has been loaded, it must now be converted into an <strong>igraph</strong> graph object. The function <strong>treeToIG</strong> requires a data frame structured such that each line represents an edge, and takes optional arguments <em>vertexinfo</em> (a list of columns of the data frame which provide information for the starting “child” vertex, or a separate data frame containing information for each vertex with the first column as the vertex name), <em>edgeweights</em>, which default to 1 if not provided, and <em>isDirected</em>, which describes whether the graph is directed (true) or undirected (false); the default is false. In this example, we want a graph with edge weights of 1 and an undirected graph because our goal is to determine whether two vertices (individuals) are related. Hence, we use the default conditions:</p><div class="row"><button class="source R toggle btn btn-xs btn-primary"><span class="glyphicon glyphicon-chevron-down"></span> R source</button>
<pre style=""><code class="source r">ig <- treeToIG(sbTree)</code></pre></div><p>We can add the other data we have about each of the nodes in ig in several ways. The sbTree dataset contains information about each child; to add that data as is to the tree, we can use the same command as before, but specify the vertexinfo parameter as follows:</p><div class="row"><button class="source R toggle btn btn-xs btn-primary"><span class="glyphicon glyphicon-chevron-down"></span> R source</button>
<pre style=""><code class="source r">ig <- treeToIG(sbTree, vertexinfo = c("year", "yield", "year.imputed", "min.repro.year"))</code></pre></div><p>If we have separate data sets with node information, we can use that instead. For the example dataset, we must first obtain the node information:</p><div class="row"><button class="source R toggle btn btn-xs btn-primary"><span class="glyphicon glyphicon-chevron-down"></span> R source</button>
<pre style=""><code class="source r">library(plyr)
nodes <- unique(sbTree[, 1:5])

# get a data frame of all parents whose parents are not known (i.e. parents who
# are not listed as children as well)
extra.nodes <- unique(data.frame(child = sbTree$parent[!sbTree$parent %in% sbTree$child & 
    !is.na(sbTree$parent)], stringsAsFactors = FALSE))

# We may not have information for these extra nodes, but they still need to be
# included in the dataset
nodes <- rbind.fill(nodes, extra.nodes)
rm(extra.nodes)

# We can now specify our vertex information using the data frame nodes:
ig <- treeToIG(sbTree, vertexinfo = nodes)</code></pre></div><p>The ig object is used in many of the other functions included with this package.</p></div><div id="functions-for-individual-vertices" class="section level1"><h1>Functions for Individual Vertices</h1><p><strong>phyViz</strong> offers several back-of-the-envelope functions that you can use to get information for individual vertices.</p><p>First, the function <strong>isParent</strong> can return a logical indicator of whether the second variety is a parent of the first variety.</p><div class="row"><button class="source R toggle btn btn-xs btn-primary"><span class="glyphicon glyphicon-chevron-down"></span> R source</button>
<pre style=""><code class="source r">isParent("Young", "Essex", sbTree)
isParent("Essex", "Young", sbTree)</code></pre>
<button class="output R toggle btn btn-xs btn-success"><span class="glyphicon glyphicon-chevron-down"></span> R output</button>
<pre style=""><code class="output r">#| [1] TRUE
#| [1] FALSE
</code></pre></div><p>Similarly, the function <strong>isChild</strong> can return a boolean variable to indicate whether or not the first variety is a child of the second variety.</p><div class="row"><button class="source R toggle btn btn-xs btn-primary"><span class="glyphicon glyphicon-chevron-down"></span> R source</button>
<pre style=""><code class="source r">isChild("Young", "Essex", sbTree)
isChild("Essex", "Young", sbTree)</code></pre>
<button class="output R toggle btn btn-xs btn-success"><span class="glyphicon glyphicon-chevron-down"></span> R output</button>
<pre style=""><code class="output r">#| [1] TRUE
#| [1] FALSE
</code></pre></div><p>It is also possible to quickly derive the year of a given variety using the <strong>getYear</strong> function:</p><div class="row"><button class="source R toggle btn btn-xs btn-primary"><span class="glyphicon glyphicon-chevron-down"></span> R source</button>
<pre style=""><code class="source r">getYear("Young", sbTree)
getYear("Essex", sbTree)</code></pre>
<button class="output R toggle btn btn-xs btn-success"><span class="glyphicon glyphicon-chevron-down"></span> R output</button>
<pre style=""><code class="output r">#| [1] 1968
#| [1] 1962
</code></pre></div><p>Fortunately, these example results make sense in that the “Young” variety is a child to the “Essex” variety by an age difference of six years.</p><p>In some cases, you may wish to have a list of all the parents of a given variety. This can be achieved using the <strong>getParent</strong> function:</p><div class="row"><button class="source R toggle btn btn-xs btn-primary"><span class="glyphicon glyphicon-chevron-down"></span> R source</button>
<pre style=""><code class="source r">getParent("Young", sbTree)
getParent("Tokyo", sbTree)
getYear("Tokyo", sbTree)</code></pre>
<button class="output R toggle btn btn-xs btn-success"><span class="glyphicon glyphicon-chevron-down"></span> R output</button>
<pre style=""><code class="output r">#| [1] "Davis" "Essex"
#| character(0)
#| [1] 1907
</code></pre></div><p>We learn from this that “Essex” is not the only parent of “Young”. We also see that as “Tokyo” is a grandparent of the dataset (with a very early year, for this particular dataset, of 1907), it does not have any documented parents.</p><p>Likewise, in other cases, you may wish to have a list of all the children of a given variety. This can be achieved using the <strong>getChild</strong> function:</p><div class="row"><button class="source R toggle btn btn-xs btn-primary"><span class="glyphicon glyphicon-chevron-down"></span> R source</button>
<pre style=""><code class="source r">getChild("Tokyo", sbTree)
getChild("Ogden", sbTree)</code></pre>
<button class="output R toggle btn btn-xs btn-success"><span class="glyphicon glyphicon-chevron-down"></span> R output</button>
<pre style=""><code class="output r">#| [1] "Ogden"    "Volstate"
#|  [1] "C1069"          "C1079"          "D51-2427"       "D55-4090"      
#|  [5] "D55-4159"       "D55-4168"       "Kent"           "N44-92"        
#|  [9] "N45-745"        "N48-1101"       "Ogden x CNS"    "Ralsoy x Ogden"
</code></pre></div><p>We find that even though the “Tokyo” variety is a grandparent of the dataset, it only had two children. However, one of its children, “Ogden”, produced twelve children.</p><p>If we want to know more than one generation past or previous, we can use the <strong>getAncestors</strong> and <strong>getDescendants</strong> function, where we specify the number of generations we wish to view. This will return a data frame to us with the labels of each ancestor or desendant, along with the number of generations each one is from the given variety.</p><p>If we only look at the first generation of ancestors of the Young variety, we should see the aforementioned output as the <strong>getParent</strong> function of the Young variety:</p><div class="row"><button class="source R toggle btn btn-xs btn-primary"><span class="glyphicon glyphicon-chevron-down"></span> R source</button>
<pre style=""><code class="source r">getAncestors("Young", sbTree, 1)</code></pre>
<button class="output R toggle btn btn-xs btn-success"><span class="glyphicon glyphicon-chevron-down"></span> R output</button>
<pre style=""><code class="output r">#|   label gen
#| 2 Davis   1
#| 1 Essex   1
</code></pre></div><p>However, if we view the first 5 generations of ancestors of the Young variety, we can view ancestors past simply the parents:</p><div class="row"><button class="source R toggle btn btn-xs btn-primary"><span class="glyphicon glyphicon-chevron-down"></span> R source</button>
<pre style=""><code class="source r">getAncestors("Young", sbTree, 5)</code></pre>
<button class="output R toggle btn btn-xs btn-success"><span class="glyphicon glyphicon-chevron-down"></span> R output</button>
<pre style=""><code class="output r">#|                      label gen
#| 27                   Davis   1
#| 26                   Essex   1
#| 23          Ralsoy x Ogden   2
#| 22 Roanoke x (Ogden x CNS)   2
#| 25                     Lee   2
#| 24                S55-7075   2
#| 15                   Ogden   3
#| 14                  Ralsoy   3
#| 21             Ogden x CNS   3
#| 19                     CNS   3
#| 20                 Roanoke   3
#| 18                   S 100   3
#| 17                N48-1248   3
#| 16                   Perry   3
#| 9                    Ogden   4
#| 7                 PI 54610   4
#| 6                    Tokyo   4
#| 10                     CNS   4
#| 8                  Clemson   4
#| 12                 Roanoke   4
#| 11                  Illini   4
#| 13 N45-745 x (Ogden x CNS)   4
#| 5                 PI 54610   5
#| 4                    Tokyo   5
#| 1              Ogden x CNS   5
#| 3                  Clemson   5
#| 2                     A.K.   5
</code></pre></div><p>Similarly, if we only look at the first generation of descendants of the Ogden variety, we should see the aforementioned output as the <strong>getChild</strong> function of the Ogden variety:</p><div class="row"><button class="source R toggle btn btn-xs btn-primary"><span class="glyphicon glyphicon-chevron-down"></span> R source</button>
<pre style=""><code class="source r">getDescendants("Ogden", sbTree, 1)</code></pre>
<button class="output R toggle btn btn-xs btn-success"><span class="glyphicon glyphicon-chevron-down"></span> R output</button>
<pre style=""><code class="output r">#|             label gen
#| 12          C1069   1
#| 11          C1079   1
#| 10       D51-2427   1
#| 9        D55-4090   1
#| 8        D55-4159   1
#| 7        D55-4168   1
#| 6            Kent   1
#| 5          N44-92   1
#| 4         N45-745   1
#| 3        N48-1101   1
#| 2     Ogden x CNS   1
#| 1  Ralsoy x Ogden   1
</code></pre></div><p>However, we can view the first 2 generations of descendants of the Ogden variety:</p><div class="row"><button class="source R toggle btn btn-xs btn-primary"><span class="glyphicon glyphicon-chevron-down"></span> R source</button>
<pre style=""><code class="source r">getDescendants("Ogden", sbTree, 2)</code></pre>
<button class="output R toggle btn btn-xs btn-success"><span class="glyphicon glyphicon-chevron-down"></span> R output</button>
<pre style=""><code class="output r">#|                      label gen
#| 28                   C1069   1
#| 27                   C1079   1
#| 26                D51-2427   1
#| 25                D55-4090   1
#| 24                D55-4159   1
#| 23                D55-4168   1
#| 22                    Kent   1
#| 21                  N44-92   1
#| 20                 N45-745   1
#| 19                N48-1101   1
#| 18             Ogden x CNS   1
#| 17          Ralsoy x Ogden   1
#| 12                Columbus   2
#| 11                  Cutler   2
#| 6                   C1266R   2
#| 4                   Semmes   2
#| 1                 D60-7965   2
#| 7                 D60-7965   2
#| 5                 D59-9289   2
#| 3                   Beeson   2
#| 2                  Calland   2
#| 15                    Hood   2
#| 14                N48-1867   2
#| 13                 D52-810   2
#| 10 N45-745 x (Ogden x CNS)   2
#| 9                  R54-168   2
#| 8  Roanoke x (Ogden x CNS)   2
#| 16                   Davis   2
</code></pre></div></div><div id="functions-for-pairs-of-vertices" class="section level1"><h1>Functions for Pairs of Vertices</h1><p>Say you have a pair of vertices, and you wish to determine the degree of separation of the shortest path between them, where edges represent parent-child relationships. You can accomplish that with the <strong>getDegree</strong> function.</p><div class="row"><button class="source R toggle btn btn-xs btn-primary"><span class="glyphicon glyphicon-chevron-down"></span> R source</button>
<pre style=""><code class="source r">getDegree("Tokyo", "Ogden", ig, sbTree)
getDegree("Tokyo", "Holladay", ig, sbTree)</code></pre>
<button class="output R toggle btn btn-xs btn-success"><span class="glyphicon glyphicon-chevron-down"></span> R output</button>
<pre style=""><code class="output r">#| [1] 1
#| [1] 7
</code></pre></div><p>As expected, the shortest path between the “Tokyo” and “Ogden” varieties has a value of one, as they are a direct parent-child relationship. However, the shortest path between “Tokyo” and one of its great-reat-great-etc-granchildren, “Holladay” has a much higher degree. Note that degree calculations in this case are not limited to one linear string of parent-child relationships; cousins and siblings and products thereof will also have computatable degrees via nonlinear strings of parent-child relationships.</p></div><div id="functions-for-the-whole-tree" class="section level1"><h1>Functions for the Whole Tree</h1><p>There are many parameters about the tree that you may wish to know that cannot easily be obtained through images and tables. With the use of the <strong>igraph</strong> package, the below function <strong>getBasicStatistics</strong> can be used to return a list of information about typical graph theoretical measurements of the whole tree. For instance, is the whole tree connected? If not, how many separated components does it contain? In addition to these parameters, the <strong>getBasicStatistics</strong> function will also return the number of nodes, the number of edges, the average path length, the graph diameter, etc.:</p><div class="row"><button class="source R toggle btn btn-xs btn-primary"><span class="glyphicon glyphicon-chevron-down"></span> R source</button>
<pre style=""><code class="source r">getBasicStatistics(ig)</code></pre>
<button class="output R toggle btn btn-xs btn-success"><span class="glyphicon glyphicon-chevron-down"></span> R output</button>
<pre style=""><code class="output r">#| $isConnected
#| [1] FALSE
#| 
#| $numComponents
#| [1] 11
#| 
#| $avePathLength
#| [1] 5.333746
#| 
#| $graphDiameter
#| [1] 13
#| 
#| $numNodes
#| [1] 230
#| 
#| $numEdges
#| [1] 340
#| 
#| $logN
#| [1] 5.438079
</code></pre></div><p>In this case, we learn that our tree is actually not all connected by parent-child edges, and that instead, it is composed of 11 separate components. We see that the average path length of the tree is 5.333, that the graph diameter is 13, and that the logN value is 5.438. We also see that the number of nodes in the tree is 230 that are connected by 340 edges.</p><p>But can we view a list of these nodes and edges? To do so, we can call the <strong>getNodes</strong> and <strong>getEdges</strong> commands to obtain non-repeated lists of the nodes and the edges in the tree. Here, we obtain a list of the 340 edges (with each row containing the names of the two connected vertices, and an edge weight, if existent). We then obtain a list of the 230 nodes. (In this example, we only view the first six items):</p><div class="row"><button class="source R toggle btn btn-xs btn-primary"><span class="glyphicon glyphicon-chevron-down"></span> R source</button>
<pre style=""><code class="source r">head(getEdges(ig))</code></pre>
<button class="output R toggle btn btn-xs btn-success"><span class="glyphicon glyphicon-chevron-down"></span> R output</button>
<pre style=""><code class="output r">#|      [,1]     [,2]           
#| [1,] "5601T"  "Hutcheson"    
#| [2,] "Adams"  "Dunfield"     
#| [3,] "A.K."   "A.K. (Harrow)"
#| [4,] "Altona" "Flambeau"     
#| [5,] "Amcor"  "Amsoy 71"     
#| [6,] "Adams"  "Amsoy"
</code></pre></div><p>We can also obtain a list of the 230 nodes:</p><div class="row"><button class="source R toggle btn btn-xs btn-primary"><span class="glyphicon glyphicon-chevron-down"></span> R source</button>
<pre style=""><code class="source r">head(getNodes(sbTree))</code></pre>
<button class="output R toggle btn btn-xs btn-success"><span class="glyphicon glyphicon-chevron-down"></span> R output</button>
<pre style=""><code class="output r">#| [1] "5601T"         "Adams"         "A.K."          "A.K. (Harrow)"
#| [5] "Altona"        "Amcor"
</code></pre></div></div><div id="visualizing-the-tree" class="section level1"><h1>Visualizing the Tree</h1><div id="plotting-the-ancestors-and-descendants-of-a-vertex" class="section level2"><h2>Plotting the Ancestors and Descendants of a Vertex</h2><p>One visualization available in <strong>phyViz</strong> allows the user to view the ancestors and descendants of a given variety. The inputted variety is highlighted in the center of the plot, ancestors are displayed to the left of the center, and descendants are displayed to the right of the center. The further left or right from the center, the larger the number of generations that particular ancestor/descendant is from the inputted and centered variety.</p><p>As such, this plotting command does not provide visual information about specific years associated with each related variety (as is done in some of the visualization tools introduced later), but it does categorize all varieties from a given generation onto the same point of the x-axis. Here, we specify that we want to plot 5 ancestor generations and 3 descendant generations of the variety Essex:</p><div class="row"><button class="source R toggle btn btn-xs btn-primary"><span class="glyphicon glyphicon-chevron-down"></span> R source</button>
<pre style=""><code class="source r">plotAncDes("Essex", sbTree, 5, 3)</code></pre><div class="row"><div class="col-md-offset-3 col-md-6"><a href="#" class="thumbnail"><img src="phyViz_files/figure-html/unnamed-chunk-19-1.png" /> </a></div></div></div><p>We verify here, as we saw earlier, that the variety Tokyo has no ancestors, when we plot with the defaults of dispalying 3 generations of ancestors and 3 generations of descendants:</p><div class="row"><button class="source R toggle btn btn-xs btn-primary"><span class="glyphicon glyphicon-chevron-down"></span> R source</button>
<pre style=""><code class="source r">plotAncDes("Tokyo", sbTree)</code></pre><div class="row"><div class="col-md-offset-3 col-md-6"><a href="#" class="thumbnail"><img src="phyViz_files/figure-html/unnamed-chunk-20-1.png" /> </a></div></div></div></div><div id="plotting-the-path-between-two-vertices" class="section level2"><h2>Plotting the Path between Two Vertices</h2><p>As this data set deals with soy bean lineages, it may be useful for agronomists to track how two varieties are related to each other via parent-child relationships. Then, any dramatic changes in protein yield, SNP varieties, and other measures of interest can be tracked across the genetic timeline, and pinpointed to certain varieties along the way.</p><p>The <strong>phyViz</strong> software can allow you to select two varieties of interest, and view the shortest pathway between them. You can produce a neat visual that informs you of all the varieties involved in the path between the two varieties of interest, as well as the years of all varieties involved in the path.</p><p>To produce and view this plot, two functions must be called in the order presented below (<strong>getPath</strong> and <strong>plotPath</strong>). We next introduce each of these two functions.</p><p>The <strong>getPath</strong> function determines the shortest path between the two inputted vertices, and takes into account whether or not the graph is directed. If there is a path, the list of vertices of the path (and their associated years) will be returned. For a directed graph, the direction matters. However, <strong>getPath</strong> will check both directions and return the path if it exists. The third parameter indicates the logical boolean of whether or not the graph is directed. Below, we look at all three possibilities (undirected and directed in reverse orders) between two varieties:</p><div class="row"><button class="source R toggle btn btn-xs btn-primary"><span class="glyphicon glyphicon-chevron-down"></span> R source</button>
<pre style=""><code class="source r">getPath("Brim", "Bedford", ig, sbTree, isDirected = FALSE)</code></pre>
<button class="output R toggle btn btn-xs btn-success"><span class="glyphicon glyphicon-chevron-down"></span> R output</button>
<pre style=""><code class="output r">#| $pathVertices
#| [1] "Brim"    "Young"   "Essex"   "T80-69"  "J74-40"  "Forrest" "Bedford"
#| 
#| $yearVertices
#| [1] "1977" "1968" "1962" "1975" "1975" "1973" "1978"
</code></pre></div>To compute paths where direction matters, we must have a directed graph<div class="row"><button class="source R toggle btn btn-xs btn-primary"><span class="glyphicon glyphicon-chevron-down"></span> R source</button>
<pre style=""><code class="source r">dirgraph = treeToIG(sbTree, vertexinfo = nodes, isDirected = TRUE)
getPath("Brim", "Bedford", dirgraph, sbTree, isDirected = TRUE)</code></pre>
<button class="message R toggle btn btn-xs btn-info"><span class="glyphicon glyphicon-chevron-down"></span> R message</button>
<pre style=""><code class="message r">#| Warning: There is no path between those two vertices
</code></pre>
<button class="output R toggle btn btn-xs btn-success"><span class="glyphicon glyphicon-chevron-down"></span> R output</button>
<pre style=""><code class="output r">#| list()
</code></pre></div><div class="row"><button class="source R toggle btn btn-xs btn-primary"><span class="glyphicon glyphicon-chevron-down"></span> R source</button>
<pre style=""><code class="source r">getPath("Bedford", "Brim", dirgraph, sbTree, isDirected = TRUE)</code></pre>
<button class="message R toggle btn btn-xs btn-info"><span class="glyphicon glyphicon-chevron-down"></span> R message</button>
<pre style=""><code class="message r">#| Warning: There is no path between those two vertices
</code></pre>
<button class="output R toggle btn btn-xs btn-success"><span class="glyphicon glyphicon-chevron-down"></span> R output</button>
<pre style=""><code class="output r">#| list()
</code></pre></div><p>We can derive from the empty list returned in the last two of the three commands that the varieties “Brim” and “Bedford” are not connected by a linear sequence of parent-child relationships. Rather, they are derived from a branch as some point, as siblings and/or cousins. Unless you are working with a dataset that must be analyzed as a directed graph, it is best to use the <strong>getPath</strong> function with the undirected specification (F) as the third parameter.</p><p>As such, we save the path between these two varieties to a variable called <strong>path</strong>:</p><div class="row"><button class="source R toggle btn btn-xs btn-primary"><span class="glyphicon glyphicon-chevron-down"></span> R source</button>
<pre style=""><code class="source r">path = getPath("Brim", "Bedford", ig, sbTree, isDirected = F)</code></pre></div><p>Now that we have a <strong>path</strong> object that consists of two lists (the variety names and years), we can plot the relationship between the two using plotPath(path)</p><div class="row"><button class="source R toggle btn btn-xs btn-primary"><span class="glyphicon glyphicon-chevron-down"></span> R source</button>
<pre style=""><code class="source r">plotPathDF = plotPath(path)</code></pre></div><p>Indeed, as predicted above, the image verifies that the two varieties “Brim” and “Bedford” are cousin-like relationships, and are not connected by a linear string of parent-child relationships. Also, as mentioned above, in this plot, the x-axis represents the years, meaning that the center of the text box for each variety represents its corresponding year.</p><p>If, for some reason, you are looking at <em>directed</em> phylogenetic trees, you will need to use the true logical condition for the third parameter of the function <strong>getPath</strong>. The example below will hopefully reassure you that if you use this condition on a pathway composed of linear parent-child relationships, then either ordering of the first two parameters will work:</p><div class="row"><button class="source R toggle btn btn-xs btn-primary"><span class="glyphicon glyphicon-chevron-down"></span> R source</button>
<pre style=""><code class="source r">dirgraph = treeToIG(sbTree, vertexinfo = nodes, isDirected = TRUE)

path = getPath("Narow", "Tokyo", dirgraph, sbTree, isDirected = TRUE)
plotPathImage <- plotPath(path)
plotPathImage</code></pre><div class="row"><div class="col-md-offset-3 col-md-6"><a href="#" class="thumbnail"><img src="phyViz_files/figure-html/unnamed-chunk-26-1.png" /> </a></div></div></div></div><div id="plotting-the-pathway-between-two-vertices-superimposed-on-tree" class="section level2"><h2>Plotting the Pathway between Two Vertices Superimposed on Tree</h2><p>If you are curious to see the above-demonstrated shortest pathway between two vertices of interest, only now superimposed over all the varieties and edges in the whole tree, <strong>phyViz</strong> has a function (<strong>plotPathOnTree</strong>) that can achieve just that.</p><!--
The internal process is as follows: 
First, the **buildSpreadTotalDF** function creates a dataframe where the varieties are shuffled such that their overlap is minimized, even though the x-axis position will represent years. (Note: **binVector** will be explained in more detail at the end of this section).

```
binVector <- c(1,4,7,10,2,5,8,11,3,6,9,12)
spreadTotalDF <- buildSpreadTotalDF(ig, binVector)
head(spreadTotalDF)
```

Next, the **buildMinusPathDF** function takes the **ig** object and the **path** object (from the **getPath** function) as inputs. From these objects, it creates a data frame object of the label, x, and y values of all nodes in the tree. However, the data frame object does not include the labels of the path varieties, as they will be treated differently.

```
plotMinusPathDF <- buildMinusPathDF(path, ig)
head(plotMinusPathDF)
```

Third, the **buildEdgeTotalDF** function takes the **ig** object and creates a data frame object of the edges between all parent-child relationships in the graph.

```
edgeTotalDF <- buildEdgeTotalDF(ig)
head(edgeTotalDF)
```

Fourth, the **buildPlotTotalDF** function takes the **ig** object and the **path** object to create a data frame object of the text label positions for the varieties in the path, as well as the edges only in the varieties in the path.

```
plotTotalDF <- buildPlotTotalDF(path, ig)
head(plotTotalDF)
```

Now that we have generated the data frames needed to construct this type of visual object, we use them as input parameters to the **plotPathOnTree** function. 

--><p>The outputted image will correctly position the node labels with x-axis representing the node year, and y-axis representing the node path index. Light grey edges between two nodes represent parent-child relationships between those nodes. To enhance the visual understanding of how the path-of-interest fits into the entire graph structure, the nodes within the path are labelled in boldface, and connected with light-green boldfaced edges.</p><div class="row"><button class="source R toggle btn btn-xs btn-primary"><span class="glyphicon glyphicon-chevron-down"></span> R source</button>
<pre style=""><code class="source r">plotTotalImage <- plotPathOnTree(path = path, ig = ig)
plotTotalImage</code></pre><div class="row"><div class="col-md-offset-3 col-md-6"><a href="#" class="thumbnail"><img src="phyViz_files/figure-html/unnamed-chunk-27-1.png" /> </a></div></div></div><p>Even though the edges of the large tree in this image are criss-crossing in all directions, that was not the focus, and hence the edges not belonging to the green path-of-interest are softly colored in a light gray. The highlight of this image was to keep all varieties in line with their appropriate year (corresponding to the x-axis), and to mitigate any overlap of the text of the varieties. Achieving this can be difficult, especially if your dataset has many varieties scrunched into a narrow set of years. That was the case with this dataset. As can be seen in the image above, most of the hundreds of varieties are associated with years between 1960 and 1975.</p><p>And this is where the explanation of the variable <strong>binVector</strong> (used as input parameters to the function <strong>spreadTotalDF</strong>) comes into play. As there is no uniform solution for this complicated problem, the <strong>phyViz</strong> package offers you the flexbility to changes these variables until you can optimize this image so that the text of the nodes of your tree overlap as little as possible. This can be done with a trial-and-error process by tweaking <strong>binVector</strong>’s order and length at the start.</p><p>Specifically, the length of <strong>binVector</strong> indicates how many bins of equal sizes should be allocated (where bins separate the vertices into groups of years). Theo order of <strong>binVector</strong> can be altered to avoid spatial collisions in labels.</p><p>The <strong>binVector</strong> will determine the order that increasing y index positions are repeatedly assigned to. For instance, if binVector = c(1,4,7,10,2,5,8,11,3,6,9,12), then y-axis position one will be assigned to a variety in the first bin of years, y-axis position two will be assigned to a variety in the fourth bin of years, …., and y-axis position thirteen will be assigned again to a variety in the first bin of years. This will be repreated until all varieties from all bins have been assigned in that order. This vector can help minimize overlap of the labelling of varieties, as varieites from the same bins (near each other on the x-axis for years) will not have consecutive y-axis values.</p><p>The two examples below will show the importance of selecting an appropriate number of bins and order of bins to minimize overlap:</p><div class="row"><button class="source R toggle btn btn-xs btn-primary"><span class="glyphicon glyphicon-chevron-down"></span> R source</button>
<pre style=""><code class="source r">plotTotalImage <- plotPathOnTree(path = path, ig = ig, binVector = 1:12)
plotTotalImage</code></pre><div class="row"><div class="col-md-offset-3 col-md-6"><a href="#" class="thumbnail"><img src="phyViz_files/figure-html/unnamed-chunk-28-1.png" /> </a></div></div></div><p>In this case, even though the number of bins is as large as the clearer-labelled image above, the order of the bins is such that varieties of consecutive x-values (years) will also have consecutive y-values (indices), and hence will be likely to overlap for years with many varieties.</p><div class="row"><button class="source R toggle btn btn-xs btn-primary"><span class="glyphicon glyphicon-chevron-down"></span> R source</button>
<pre style=""><code class="source r">plotTotalImage <- plotPathOnTree(path = path, ig = ig, binVector = 1:2)
plotTotalImage</code></pre><div class="row"><div class="col-md-offset-3 col-md-6"><a href="#" class="thumbnail"><img src="phyViz_files/figure-html/unnamed-chunk-29-1.png" /> </a></div></div></div><p>In this example, we see that with such a small number of bins chosen, the y-axis position designation will be similar to its original random state, and there is again much overlap in text variety labels in the year ranges where varieties occur the most.</p></div><div id="generating-a-pairwise-distance-matrix-between-set-of-vertices" class="section level2"><h2>Generating a Pairwise Distance Matrix between Set of Vertices</h2><p>It may also be of interest to scientists studying phylogenetics to generate heat maps where the color of each index of the map indicates the distance or years between two vertices.</p><p>The package <strong>phyViz</strong> also provides functions for that purpose. Specifically, for a given set of vertices, a heat map of the distance (degree of the shortest path) between all pairs of vertices can be constructed with the <strong>plotDegMatrix</strong> function:</p><div class="row"><button class="source R toggle btn btn-xs btn-primary"><span class="glyphicon glyphicon-chevron-down"></span> R source</button>
<pre style=""><code class="source r">varieties <- c("Beeson", "Brim", "Dillon", "Narow", "Zane", "Hood", "York", "Calland", 
    "Columbus", "Crawford", "Kershaw", "Kent", "Bragg", "Davis", "Tokyo", "Hagood", 
    "Young", "Essex", "Holladay", "Cook", "Century", "Pella", "Forrest", "Gasoy", 
    "Cutler")
heatMapDegreeImage <- plotDegMatrix(varieties, ig, sbTree)
heatMapDegreeImage</code></pre><div class="row"><div class="col-md-offset-3 col-md-6"><a href="#" class="thumbnail"><img src="phyViz_files/figure-html/unnamed-chunk-30-1.png" /> </a></div></div></div><p>In a similar function, <strong>plotYearMatrix</strong>, the difference in years between all pairwise combinations of vertices can be constructed and viewed:</p><div class="row"><button class="source R toggle btn btn-xs btn-primary"><span class="glyphicon glyphicon-chevron-down"></span> R source</button>
<pre style=""><code class="source r">varieties <- c("Beeson", "Brim", "Dillon", "Narow", "Zane", "Hood", "York", "Calland", 
    "Columbus", "Crawford", "Kershaw", "Kent", "Bragg", "Davis", "Tokyo", "Hagood", 
    "Young", "Essex", "Holladay", "Cook", "Century", "Pella", "Forrest", "Gasoy", 
    "Cutler")
heatMapYearImage <- plotYearMatrix(varieties, sbTree)
heatMapYearImage</code></pre><div class="row"><div class="col-md-offset-3 col-md-6"><a href="#" class="thumbnail"><img src="phyViz_files/figure-html/unnamed-chunk-31-1.png" /> </a></div></div></div><p>Running this function on this particular set of vertices shows that most combinations of varieties are only a few decades apart in years, with only very few sets of vertices showing difference in years on the order of five or six decades.</p></div></div><div id="conclusion" class="section level1"><h1>Conclusion</h1><p>The various options of the <strong>phyViz</strong> package can offer you different ways of visually interpreting your trees that each come with advantages and disadvantages. While some visualizations connect nodes to their years, other visualizations lax this idea, and instead connect nodes based on their generation surrounding a given node. And still other visualizations from <strong>phyViz</strong> will allow you to either focus on one pathway, or view that pathway superimposed across the entire tree for reference. Hopefully, the package will have something to offer to you in your data analysis.</p></div>

          <p class="text-muted" id="credit">
            Styled with <a href="https://github.com/jimhester/knitrBootstrap">knitrBootstrap</a>
          </p>

        </div>

        
      </div>
    </div>

        <!-- dynamically load mathjax for compatibility with self-contained -->
    <script>
      (function () {
          var script = document.createElement("script");
          script.type = "text/javascript";
          script.src  = "https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
          document.getElementsByTagName("head")[0].appendChild(script);
      })();
    </script>
      </body>
</html>
